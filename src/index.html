<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>vncaa</title>
    <link rel="icon" href="/static/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/static/favicon.ico" type="image/x-icon">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png">
    <link rel="manifest" href="/static/site.webmanifest">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            /* Prevent pull-to-refresh and overscroll */
            overscroll-behavior: none;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            max-width: 1024px;
            margin: 0 auto;
            /* Safe area insets for notched devices */
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        .vnc-container {
            flex: 1;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            overflow: hidden;
            background: #000;
            /* Better touch handling */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #vnc-iframe {
            width: 100%;
            height: 100%;
            border: none;
            /* Optimize touch handling for VNC */
            touch-action: none;
        }

        .prompt-container {
            padding: 12px;
            background: #2a2a2a;
            border-top: 1px solid #444;
            /* Safe area for bottom notch/home indicator */
            padding-bottom: max(12px, env(safe-area-inset-bottom));
            /* Prevent container from being hidden by keyboard */
            position: relative;
            z-index: 10;
        }

        .prompt-form {
            display: flex;
            gap: 8px;
        }

        #prompt-input {
            flex: 1;
            padding: 12px 16px;
            min-height: 44px; /* Minimum touch target */
            font-size: 16px; /* Prevent iOS zoom on focus */
            border: 2px solid #444;
            border-radius: 8px;
            background: #1a1a1a;
            color: #fff;
            outline: none;
            /* Improve mobile text input */
            -webkit-appearance: none;
            appearance: none;
            pointer-events: auto;
            touch-action: manipulation;
        }

        #prompt-input:focus {
            border-color: #6366f1;
        }

        #prompt-input::placeholder {
            color: #666;
        }

        #send-btn {
            padding: 12px 24px;
            min-height: 44px; /* Minimum touch target */
            min-width: 64px;
            font-size: 16px;
            font-weight: 600;
            background: #6366f1;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            /* Better touch feedback */
            -webkit-tap-highlight-color: rgba(99, 102, 241, 0.3);
        }

        #send-btn:hover {
            background: #5558e3;
        }

        #send-btn:active {
            background: #4447c7;
        }

        #send-btn:disabled {
            background: #444;
            cursor: not-allowed;
        }

        .status {
            text-align: center;
            padding: 8px;
            font-size: 13px;
            color: #666;
            min-height: 32px; /* Ensure visibility */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status.connected {
            color: #22c55e;
        }

        .status.disconnected {
            color: #ef4444;
        }

        .font-control {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            color: #999;
            font-size: 14px;
        }

        .font-control label {
            white-space: nowrap;
            font-weight: 500;
        }

        .font-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #444;
            border-radius: 3px;
            outline: none;
            pointer-events: auto;
            touch-action: pan-x;
            cursor: pointer;
        }

        .font-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #6366f1;
            cursor: pointer;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .font-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #6366f1;
            cursor: pointer;
            border-radius: 50%;
            border: none;
            transition: background 0.2s;
        }

        .font-slider::-webkit-slider-thumb:hover {
            background: #5558e3;
        }

        .font-slider::-moz-range-thumb:hover {
            background: #5558e3;
        }

        .font-size-display {
            min-width: 45px;
            text-align: right;
            color: #fff;
            font-weight: 600;
        }

        /* Tablet breakpoint */
        @media (max-width: 768px) {
            .container {
                max-width: 100%;
            }

            .prompt-form {
                gap: 6px;
            }
        }

        /* Mobile breakpoint */
        @media (max-width: 600px) {
            .prompt-container {
                padding: 10px;
                padding-bottom: max(10px, env(safe-area-inset-bottom));
            }

            .prompt-form {
                gap: 6px;
            }

            #prompt-input {
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 12px 14px;
            }

            #send-btn {
                padding: 12px 16px;
                font-size: 16px;
                min-width: 56px;
            }

            .status {
                font-size: 12px;
                padding: 6px;
            }
        }

        /* Small mobile breakpoint */
        @media (max-width: 375px) {
            .prompt-form {
                gap: 4px;
            }

            #send-btn {
                padding: 12px;
                min-width: 50px;
            }
        }

        /* Landscape mobile optimization */
        @media (max-height: 500px) and (orientation: landscape) {
            .prompt-container {
                padding: 8px;
                padding-bottom: max(8px, env(safe-area-inset-bottom));
            }

            #prompt-input {
                padding: 8px 12px;
                min-height: 40px;
            }

            #send-btn {
                padding: 8px 16px;
                min-height: 40px;
            }

            .status {
                padding: 4px;
                min-height: 24px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="vnc-container">
            <iframe
                id="vnc-iframe"
                allow="pointer-lock; fullscreen; clipboard-read; clipboard-write"
                allowfullscreen
            ></iframe>
        </div>
        <div class="prompt-container">
            <form class="prompt-form" id="prompt-form">
                <input
                    type="text"
                    id="prompt-input"
                    placeholder="Type your prompt here..."
                    autocomplete="off"
                    autocapitalize="sentences"
                >
                <button type="submit" id="send-btn">Send</button>
            </form>
            <div class="font-control">
                <label for="font-slider">Font Size:</label>
                <input
                    type="range"
                    id="font-slider"
                    class="font-slider"
                    min="8"
                    max="72"
                    step="1"
                    value="20"
                >
                <span class="font-size-display" id="font-size-display">20px</span>
            </div>
            <div class="status" id="status">Connecting...</div>
        </div>
    </div>

    <script>
        const promptInput = document.getElementById('prompt-input');
        const promptForm = document.getElementById('prompt-form');
        const sendBtn = document.getElementById('send-btn');
        const statusEl = document.getElementById('status');
        const fontSlider = document.getElementById('font-slider');
        const fontSizeDisplay = document.getElementById('font-size-display');

        let ws = null;
        let reconnectTimer = null;
        let fontSizeTimeout = null;

        // Handle keyboard visibility on mobile
        function setupKeyboardHandling() {
            if (!window.visualViewport) return;

            const container = document.querySelector('.container');
            const vncContainer = document.querySelector('.vnc-container');
            let isKeyboardVisible = false;

            function handleViewportResize() {
                // Detect if keyboard is open (viewport height significantly reduced)
                const viewportHeight = window.visualViewport.height;
                const windowHeight = window.innerHeight;
                const keyboardVisible = windowHeight - viewportHeight > 150;

                // Only update if state changed to avoid unnecessary reflows
                if (keyboardVisible !== isKeyboardVisible) {
                    isKeyboardVisible = keyboardVisible;

                    if (keyboardVisible) {
                        // Keyboard is visible - adjust layout
                        container.style.height = `${viewportHeight}px`;
                        vncContainer.style.minHeight = '0';
                    } else {
                        // Keyboard hidden - restore layout with a small delay
                        // to ensure smooth transition
                        requestAnimationFrame(() => {
                            container.style.height = '';
                            vncContainer.style.minHeight = '';
                        });
                    }
                }
            }

            window.visualViewport.addEventListener('resize', handleViewportResize);
            window.visualViewport.addEventListener('scroll', handleViewportResize);
        }

        // Initialize keyboard handling
        setupKeyboardHandling();

        function connect() {
            const wsUrl = `ws://${window.location.host}/prompt`;
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                statusEl.textContent = 'Connected';
                statusEl.className = 'status connected';
                sendBtn.disabled = false;
            };

            ws.onclose = () => {
                statusEl.textContent = 'Disconnected - reconnecting...';
                statusEl.className = 'status disconnected';
                sendBtn.disabled = true;

                // Reconnect after 2 seconds
                reconnectTimer = setTimeout(connect, 2000);
            };

            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
            };
        }

        async function updateFontSize(size) {
            try {
                const response = await fetch('/api/font-size', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ size: parseFloat(size) }),
                });

                const data = await response.json();

                if (!response.ok) {
                    console.error('Font size update failed:', data.message);
                    statusEl.textContent = `Error: ${data.message}`;
                    statusEl.className = 'status disconnected';
                    setTimeout(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            statusEl.textContent = 'Connected';
                            statusEl.className = 'status connected';
                        }
                    }, 3000);
                } else {
                    console.log('Font size updated:', data.message);
                }
            } catch (error) {
                console.error('Font size update error:', error);
                statusEl.textContent = 'Font size update failed';
                statusEl.className = 'status disconnected';
                setTimeout(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        statusEl.textContent = 'Connected';
                        statusEl.className = 'status connected';
                    }
                }, 3000);
            }
        }

        // Handle font size slider changes with debounce
        function handleFontSliderChange(e) {
            const size = e.target.value;
            fontSizeDisplay.textContent = `${size}px`;

            // Clear existing timeout
            if (fontSizeTimeout) {
                clearTimeout(fontSizeTimeout);
                fontSizeTimeout = null;
            }

            // Debounce: only send after user stops dragging for 500ms
            fontSizeTimeout = setTimeout(() => {
                updateFontSize(size);
                fontSizeTimeout = null;
            }, 500);
        }

        // Use both 'input' and 'change' events for better compatibility
        fontSlider.addEventListener('input', handleFontSliderChange);
        fontSlider.addEventListener('change', (e) => {
            // On change event (when user releases), ensure update is sent immediately
            if (fontSizeTimeout) {
                clearTimeout(fontSizeTimeout);
                fontSizeTimeout = null;
            }
            updateFontSize(e.target.value);
        });

        promptForm.addEventListener('submit', (e) => {
            e.preventDefault();

            const text = promptInput.value.trim();
            if (!text || !ws || ws.readyState !== WebSocket.OPEN) return;

            ws.send(text);
            promptInput.value = '';

            // Blur the input first to ensure it's in a clean state
            promptInput.blur();

            // Return focus to VNC iframe after sending prompt
            setTimeout(() => {
                vncIframe.focus();
            }, 0);
        });

        // Ensure prompt input remains functional after viewport changes
        promptInput.addEventListener('blur', () => {
            // Use a small timeout to ensure the input is ready for next focus
            setTimeout(() => {
                promptInput.readOnly = false;
            }, 10);
        });

        promptInput.addEventListener('focus', () => {
            promptInput.readOnly = false;
        });

        // Set VNC iframe URL based on current host
        const vncIframe = document.getElementById('vnc-iframe');
        const vncHost = window.location.hostname || 'localhost';
        vncIframe.src = `http://${vncHost}:6080/vnc.html?autoconnect=true&resize=scale&show_dot=true&view_clip=false`;

        // Start connection
        connect();

        // Focus VNC iframe on load - only focus prompt input when user clicks it
        vncIframe.addEventListener('load', () => {
            vncIframe.focus();
        });
    </script>
</body>
</html>
